<!DOCTYPE html>
<html lang="en"><script type="text/javascript">try {
(function injectPageScriptAPI(scriptName, shouldOverrideWebSocket, shouldOverrideWebRTC, isInjected) { 

    'use strict';

    /**
     * If script have been injected into a frame via contentWindow then we can simply take the copy of messageChannel left for us by parent document
     * Otherwise creates new message channel that sends a message to the content-script to check if request should be allowed or not.
     */
    var messageChannel = isInjected ? window[scriptName] : (function () {

        // Save original postMessage and addEventListener functions to prevent webpage from tampering both.
        var postMessage = window.postMessage;
        var addEventListener = window.addEventListener;

        // Current request ID (incremented every time we send a new message)
        var currentRequestId = 0;
        var requestsMap = {};

        /**
         * Handles messages sent from the content script back to the page script.
         *
         * @param event Event with necessary data
         */
        var onMessageReceived = function (event) {

            if (!event.data || !event.data.direction || event.data.direction !== "to-page-script@abu") {
                return;
            }

            var requestData = requestsMap[event.data.requestId];
            if (requestData) {
                var wrapper = requestData.wrapper;
                requestData.onResponseReceived(wrapper, event.data.block);
                delete requestsMap[event.data.requestId];
            }
        };

        /**
         * @param url                The URL to which wrapped object is willing to connect
         * @param requestType        Request type ( WEBSOCKET or WEBRTC)
         * @param wrapper            WebSocket wrapper instance
         * @param onResponseReceived Called when response is received
         */
        var sendMessage = function (url, requestType, wrapper, onResponseReceived) {

            if (currentRequestId === 0) {
                // Subscribe to response when this method is called for the first time
                addEventListener.call(window, "message", onMessageReceived, false);
            }

            var requestId = ++currentRequestId;
            requestsMap[requestId] = {
                wrapper: wrapper,
                onResponseReceived: onResponseReceived
            };

            var message = {
                requestId: requestId,
                direction: 'from-page-script@abu',
                elementUrl: url,
                documentUrl: document.URL,
                requestType: requestType
            };

            // Send a message to the background page to check if the request should be blocked
            postMessage.call(window, message, "*");
        };

        return {
            sendMessage: sendMessage
        };

    })();

    /*
     * In some case Chrome won't run content scripts inside frames.
     * So we have to intercept access to contentWindow/contentDocument and manually inject wrapper script into this context
     *
     * Based on: https://github.com/adblockplus/adblockpluschrome/commit/1aabfb3346dc0821c52dd9e97f7d61b8c99cd707
     */
    var injectedToString = Function.prototype.toString.bind(injectPageScriptAPI);

    var injectedFramesAdd;
    var injectedFramesHas;
    if (window.WeakSet instanceof Function) {
        var injectedFrames = new WeakSet();
        injectedFramesAdd = WeakSet.prototype.add.bind(injectedFrames);
        injectedFramesHas = WeakSet.prototype.has.bind(injectedFrames);
    } else {
        var frames = [];
        injectedFramesAdd = function (el) {
            if (frames.indexOf(el) < 0) {
                frames.push(el);
            }
        };
        injectedFramesHas = function (el) {
            return frames.indexOf(el) >= 0;
        };
    }

    /**
     * Injects wrapper's script into passed window
     * @param contentWindow Frame's content window
     */
    function injectPageScriptAPIInWindow(contentWindow) {
        try {
            if (contentWindow && !injectedFramesHas(contentWindow)) {
                injectedFramesAdd(contentWindow);
                contentWindow[scriptName] = messageChannel; // Left message channel for the injected script
                var args = "'" + scriptName + "', " + shouldOverrideWebSocket + ", " + shouldOverrideWebRTC + ", true";
                contentWindow.eval("(" + injectedToString() + ")(" + args + ");");
                delete contentWindow[scriptName];
            }
        } catch (e) {
        }
    }

    /**
     * Overrides access to contentWindow/contentDocument for the passed HTML element's interface (iframe, frame, object)
     * If the content of one of these objects is requested we will inject our wrapper script.
     * @param iface HTML element's interface
     */
    function overrideContentAccess(iface) {

        var contentWindowDescriptor = Object.getOwnPropertyDescriptor(iface.prototype, "contentWindow");
        var contentDocumentDescriptor = Object.getOwnPropertyDescriptor(iface.prototype, "contentDocument");

        // Apparently in HTMLObjectElement.prototype.contentWindow does not exist
        // in older versions of Chrome such as 42.
        if (!contentWindowDescriptor) {
            return;
        }

        var getContentWindow = Function.prototype.call.bind(contentWindowDescriptor.get);
        var getContentDocument = Function.prototype.call.bind(contentDocumentDescriptor.get);

        contentWindowDescriptor.get = function () {
            var contentWindow = getContentWindow(this);
            injectPageScriptAPIInWindow(contentWindow);
            return contentWindow;
        };
        contentDocumentDescriptor.get = function () {
            injectPageScriptAPIInWindow(getContentWindow(this));
            return getContentDocument(this);
        };

        Object.defineProperty(iface.prototype, "contentWindow", contentWindowDescriptor);
        Object.defineProperty(iface.prototype, "contentDocument", contentDocumentDescriptor);
    }

    var interfaces = [HTMLFrameElement, HTMLIFrameElement, HTMLObjectElement];
    for (var i = 0; i < interfaces.length; i++) {
        overrideContentAccess(interfaces[i]);
    }

    /**
     * Defines properties in destination object
     * @param src Source object
     * @param dest Destination object
     * @param properties Properties to copy
     */
    var copyProperties = function (src, dest, properties) {
        for (var i = 0; i < properties.length; i++) {
            var prop = properties[i];
            var descriptor = Object.getOwnPropertyDescriptor(src, prop);
            // Passed property may be undefined
            if (descriptor) {
                Object.defineProperty(dest, prop, descriptor);
            }
        }
    };

    /**
     * Check request by sending message to content script
     * @param url URL to block
     * @param type Request type
     * @param callback Result callback
     */
    var checkRequest = function (url, type, callback) {
        messageChannel.sendMessage(url, type, this, function (wrapper, blockConnection) {
            callback(blockConnection);
        });
    };

    /**
     * The function overrides window.WebSocket with our wrapper, that will check url with filters through messaging with content-script.
     *
     * IMPORTANT NOTE:
     * This function is first loaded as a content script. The only purpose of it is to call
     * the "toString" method and use resulting string as a text content for injected script.
     */
    var overrideWebSocket = function () { 

        if (!(window.WebSocket instanceof Function)) {
            return;
        }

        /**
         * WebSocket wrapper implementation.
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/349
         *
         * Based on:
         * https://github.com/adblockplus/adblockpluschrome/commit/457a336ee55a433217c3ffe5d363e5c6980f26f4
         */

        /**
         * As far as possible we must track everything we use that could be sabotaged by the website later in order to circumvent us.
         */
        var RealWebSocket = WebSocket;
        var closeWebSocket = Function.prototype.call.bind(RealWebSocket.prototype.close);

        function WrappedWebSocket(url, protocols) {
            // Throw correct exceptions if the constructor is used improperly.
            if (!(this instanceof WrappedWebSocket)) {
                return RealWebSocket();
            }
            if (arguments.length < 1) {
                return new RealWebSocket();
            }

            var websocket = new RealWebSocket(url, protocols);

            // This is the key point: checking if this WS should be blocked or not
            // Don't forget that the type of 'websocket.url' is String, but 'url 'parameter might have another type.
            checkRequest(websocket.url, 'WEBSOCKET', function (blocked) {
                if (blocked) {
                    closeWebSocket(websocket);
                }
            });

            return websocket;
        }

        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/488
        WrappedWebSocket.prototype = RealWebSocket.prototype;
        window.WebSocket = WrappedWebSocket.bind();

        copyProperties(RealWebSocket, WebSocket, ["CONNECTING", "OPEN", "CLOSING", "CLOSED", "name", "prototype"]);

        RealWebSocket.prototype.constructor = WebSocket;

    };

    /**
     * The function overrides window.RTCPeerConnection with our wrapper, that will check ice servers URLs with filters through messaging with content-script.
     *
     * IMPORTANT NOTE:
     * This function is first loaded as a content script. The only purpose of it is to call
     * the "toString" method and use resulting string as a text content for injected script.
     */
    var overrideWebRTC = function () { 


        if (!(window.RTCPeerConnection instanceof Function) &&
            !(window.webkitRTCPeerConnection instanceof Function)) {
            return;
        }

        /**
         * RTCPeerConnection wrapper implementation.
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/588
         *
         * Based on:
         * https://github.com/adblockplus/adblockpluschrome/commit/af0585137be19011eace1cf68bf61eed2e6db974
         *
         * Chromium webRequest API doesn't allow the blocking of WebRTC connections
         * https://bugs.chromium.org/p/chromium/issues/detail?id=707683
         */

        var RealRTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection;
        var closeRTCPeerConnection = Function.prototype.call.bind(RealRTCPeerConnection.prototype.close);

        var RealArray = Array;
        var RealString = String;
        var createObject = Object.create;
        var defineProperty = Object.defineProperty;

        /**
         * Convert passed url to string
         * @param url URL
         * @returns {string}
         */
        function urlToString(url) {
            if (typeof url !== "undefined") {
                return RealString(url);
            }
        }

        /**
         * Creates new immutable array from original with some transform function
         * @param original
         * @param transform
         * @returns {*}
         */
        function safeCopyArray(original, transform) {

            if (original === null || typeof original !== "object") {
                return original;
            }

            var immutable = RealArray(original.length);
            for (var i = 0; i < immutable.length; i++) {
                defineProperty(immutable, i, {
                    configurable: false, enumerable: false, writable: false,
                    value: transform(original[i])
                });
            }
            defineProperty(immutable, "length", {
                configurable: false, enumerable: false, writable: false,
                value: immutable.length
            });
            return immutable;
        }

        /**
         * Protect configuration from mutations
         * @param configuration RTCPeerConnection configuration object
         * @returns {*}
         */
        function protectConfiguration(configuration) {

            if (configuration === null || typeof configuration !== "object") {
                return configuration;
            }

            var iceServers = safeCopyArray(
                configuration.iceServers,
                function (iceServer) {

                    var url = iceServer.url;
                    var urls = iceServer.urls;

                    // RTCPeerConnection doesn't iterate through pseudo Arrays of urls.
                    if (typeof urls !== "undefined" && !(urls instanceof RealArray)) {
                        urls = [urls];
                    }

                    return createObject(iceServer, {
                        url: {
                            configurable: false, enumerable: false, writable: false,
                            value: urlToString(url)
                        },
                        urls: {
                            configurable: false, enumerable: false, writable: false,
                            value: safeCopyArray(urls, urlToString)
                        }
                    });
                }
            );

            return createObject(configuration, {
                iceServers: {
                    configurable: false, enumerable: false, writable: false,
                    value: iceServers
                }
            });
        }

        /**
         * Check WebRTC connection's URL and close if it's blocked by rule
         * @param connection Connection
         * @param url URL to check
         */
        function checkWebRTCRequest(connection, url) {
            checkRequest(url, 'WEBRTC', function (blocked) {
                if (blocked) {
                    try {
                        closeRTCPeerConnection(connection);
                    } catch (e) {
                        // Ignore exceptions
                    }
                }
            });
        }

        /**
         * Check each URL of ice server in configuration for blocking.
         *
         * @param connection RTCPeerConnection
         * @param configuration Configuration for RTCPeerConnection
         * https://developer.mozilla.org/en-US/docs/Web/API/RTCConfiguration
         */
        function checkConfiguration(connection, configuration) {

            if (!configuration || !configuration.iceServers) {
                return;
            }

            var iceServers = configuration.iceServers;
            for (var i = 0; i < iceServers.length; i++) {

                var iceServer = iceServers[i];
                if (!iceServer) {
                    continue;
                }

                if (iceServer.url) {
                    checkWebRTCRequest(connection, iceServer.url);
                }

                if (iceServer.urls) {
                    for (var j = 0; j < iceServer.urls.length; j++) {
                        checkWebRTCRequest(connection, iceServer.urls[j]);
                    }
                }
            }
        }

        /**
         * Overrides setConfiguration method
         * https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection/setConfiguration
         */
        if (RealRTCPeerConnection.prototype.setConfiguration) {

            var realSetConfiguration = Function.prototype.call.bind(RealRTCPeerConnection.prototype.setConfiguration);

            RealRTCPeerConnection.prototype.setConfiguration = function (configuration) {
                configuration = protectConfiguration(configuration);
                // Call the real method first, so that validates the configuration
                realSetConfiguration(this, configuration);
                checkConfiguration(this, configuration);
            };
        }

        function WrappedRTCPeerConnection(configuration, arg) {

            if (!(this instanceof WrappedRTCPeerConnection)) {
                return RealRTCPeerConnection();
            }

            configuration = protectConfiguration(configuration);

            /**
             * The old webkitRTCPeerConnection constructor takes an optional second argument and we must pass it.
             */
            var connection = new RealRTCPeerConnection(configuration, arg);
            checkConfiguration(connection, configuration);
            return connection;
        }

        WrappedRTCPeerConnection.prototype = RealRTCPeerConnection.prototype;

        var boundWrappedRTCPeerConnection = WrappedRTCPeerConnection.bind();
        copyProperties(RealRTCPeerConnection, boundWrappedRTCPeerConnection, ["caller", "generateCertificate", "name", "prototype"]);
        RealRTCPeerConnection.prototype.constructor = boundWrappedRTCPeerConnection;

        if ("RTCPeerConnection" in window) {
            window.RTCPeerConnection = boundWrappedRTCPeerConnection;
        }
        if ("webkitRTCPeerConnection" in window) {
            window.webkitRTCPeerConnection = boundWrappedRTCPeerConnection;
        }
    };

    if (shouldOverrideWebSocket) {
        overrideWebSocket();
    }

    if (shouldOverrideWebRTC) {
        overrideWebRTC();
    }
})('wrapper-script-3580435217361767', false, true);
} catch (ex) { console.error('Error executing AG js: ' + ex); }
(function () {
            var current = document.currentScript;
            var parent = current && current.parentNode;
            if (parent) {
                parent.removeChild(current);
            }
        })();</script><head>
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Vim help pages, always up-to-date">
<title>Vim: usr_11.txt</title>
<link rel="shortcut icon" href="https://vimhelp.org/favicon.ico">
<!-- favicon is based on http://amnoid.de/tmp/vim_solidbright_512.png and is used with permission by its author -->
<link rel="stylesheet" href="Vim%20usr_11.txt_Recovering%20from%20a%20crash_files/vimhelp.css" type="text/css">

<link rel="stylesheet" class="select2-css" href="Vim%20usr_11.txt_Recovering%20from%20a%20crash_files/select2.min.css" integrity="sha256-zaSoHBhwFdle0scfGEFUCwggPN7F+ip9XRglo8IWb4w=" crossorigin="anonymous">
<script defer="defer" src="Vim%20usr_11.txt_Recovering%20from%20a%20crash_files/jquery.min.js" integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0=" crossorigin="anonymous"></script>
<script defer="defer" src="Vim%20usr_11.txt_Recovering%20from%20a%20crash_files/select2.min.js" integrity="sha256-9yRP/2EFlblE92vzCA10469Ctd0jT48HnmmMw5rJZrA=" crossorigin="anonymous"></script>
<script defer="defer" src="Vim%20usr_11.txt_Recovering%20from%20a%20crash_files/vimhelp.js"></script>
</head><body>
<div class="bar">
  <div class="ql">
Quick links:
<a href="https://vimhelp.org/">help overview</a> ·
<a href="https://vimhelp.org/quickref.txt.html">quick reference</a> ·
<a href="https://vimhelp.org/usr_toc.txt.html">user manual toc</a> ·
<a href="https://vimhelp.org/#reference_toc">reference manual toc</a>
· <a href="https://vimhelp.org/vim_faq.txt.html">faq</a></div>
  <div class="srch">
    <select id="vh-select-tag" data-select2-id="select2-data-vh-select-tag" tabindex="-1" class="select2-hidden-accessible" aria-hidden="true" style="display: inline-block;"></select><span class="select2 select2-container select2-container--default" dir="ltr" data-select2-id="select2-data-1-4glz" style="width: 100%;"><span class="selection"><span class="select2-selection select2-selection--single" role="combobox" aria-haspopup="true" aria-expanded="false" tabindex="0" aria-disabled="false" aria-labelledby="select2-vh-select-tag-container" aria-controls="select2-vh-select-tag-container"><span class="select2-selection__rendered" id="select2-vh-select-tag-container" role="textbox" aria-readonly="true" title="Go to keyword"><span class="select2-selection__placeholder">Go to keyword</span></span><span class="select2-selection__arrow" role="presentation"><b role="presentation"></b></span></span></span><span class="dropdown-wrapper" aria-hidden="true"></span></span>
  </div>
  <form class="srch" action="https://duckduckgo.com" method="get" target="_blank" rel="noopener noreferrer">
    <input type="hidden" name="sites" value="vimhelp.org">
    <input type="search" name="q" id="vh-srch-input" placeholder="Site search">
  </form>
</div>

<main>
<div id="vh-content">
<pre><span id="usr_11.txt" class="t">usr_11.txt</span>    For <span class="i">Vim version 9.0.</span>  Last change: 2020 Oct 25

                     VIM USER MANUAL <a href="https://vimhelp.org/motion.txt.html#-" class="d">-</a> by <a href="https://vimhelp.org/intro.txt.html#Bram" class="d">Bram</a> <a href="https://vimhelp.org/intro.txt.html#Moolenaar" class="d">Moolenaar</a>

                           Recovering from <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> crash


Did your computer crash?  And you just spent hours editing?  Don't panic!  Vim
stores enough information to be able to restore most of your work.  This
chapter shows you how to get your work back and explains how the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a>
used.

<a href="#11.1" class="l">11.1</a>  Basic <a href="https://vimhelp.org/recover.txt.html#recovery" class="d">recovery</a>
<a href="#11.2" class="l">11.2</a>  Where <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> the swap file?
<a href="#11.3" class="l">11.3</a>  Crashed or not?
<a href="#11.4" class="l">11.4</a>  Further reading

     Next chapter: <a href="https://vimhelp.org/usr_12.txt.html#usr_12.txt" class="l">usr_12.txt</a>  Clever tricks
 Previous chapter: <a href="https://vimhelp.org/usr_10.txt.html#usr_10.txt" class="l">usr_10.txt</a>  Making big changes
Table of contents: <a href="https://vimhelp.org/usr_toc.txt.html#usr_toc.txt" class="l">usr_toc.txt</a>

<span class="h">==============================================================================</span>
<span id="11.1" class="t">11.1</span>  Basic <a href="https://vimhelp.org/recover.txt.html#recovery" class="d">recovery</a>

In most cases recovering <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> quite simple, assuming you know which file
you were editing (and the harddisk <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> still working).  Start Vim on the file,
with the "<a href="https://vimhelp.org/starting.txt.html#-r" class="d">-r</a>" argument added: 
<span class="e"></span>
<span class="e">        vim -r help.txt</span>
<span class="e"></span>
Vim will read the swap file (used to store text you were editing) and may read
bits and pieces of the original file.  If Vim recovered your changes you will
see these <a href="https://vimhelp.org/message.txt.html#messages" class="d">messages</a> (with different file names, of course):

<span class="h">        Using swap file ".help.txt.swp" </span>
<span class="h">        Original file "~/vim/runtime/doc/help.txt" </span>
<span class="h">        Recovery completed. You should check if everything is OK. </span>
<span class="h">        (You might want to write out this file under another name </span>
<span class="h">        and run diff with the original file to check for changes) </span>
<span class="h">        You may want to delete the .swp file now. </span>

To be on the safe side, write this file under another name: 
<span class="e"></span>
<span class="e">        :write help.txt.recovered</span>
<span class="e"></span>
Compare the file with the original file to check if you ended up with what you
expected.  Vimdiff <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> very useful for this <a href="https://vimhelp.org/usr_08.txt.html#08.7" class="l">08.7</a><a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>  For example: 
<span class="e"></span>
<span class="e">        :write help.txt.recovered</span>
<span class="e">        :edit #</span>
<span class="e">        :diffsp help.txt</span>
<span class="e"></span>
Watch out for the original file to contain <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> more recent version (you saved
the file just before the computer crashed).  And check that no lines are
missing (something went wrong that Vim could not recover).
   If Vim produces warning <a href="https://vimhelp.org/message.txt.html#messages" class="d">messages</a> when recovering, read them carefully.
This <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> rare though.

If the <a href="https://vimhelp.org/recover.txt.html#recovery" class="d">recovery</a> resulted in text that <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> exactly the same <a href="https://vimhelp.org/motion.txt.html#as" class="d">as</a> the file
contents, you will get this message:

<span class="h">        Using swap file ".help.txt.swp" </span>
<span class="h">        Original file "~/vim/runtime/doc/help.txt" </span>
<span class="h">        Recovery completed. Buffer contents equals file contents. </span>
<span class="h">        You may want to delete the .swp file now. </span>

This usually happens if you already recovered your changes, or you wrote the
file after making changes.  It <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> safe to delete the swap file now.

It <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> normal that the last few changes can not be recovered.  Vim flushes the
changes to disk when you don't type for about four seconds, or after typing
about two hundred characters.  This <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> set with the <a href="https://vimhelp.org/options.txt.html#%27updatetime%27" class="o">'updatetime'</a> and
<a href="https://vimhelp.org/options.txt.html#%27updatecount%27" class="o">'updatecount'</a> options.  Thus when Vim didn't get <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> chance to save itself when
the system went down, the changes after the last flush will be lost.

If you were editing without <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file name, give an empty <a href="https://vimhelp.org/eval.txt.html#string" class="d">string</a> <a href="https://vimhelp.org/motion.txt.html#as" class="d">as</a> argument: 
<span class="e"></span>
<span class="e">        vim -r ""</span>
<span class="e"></span>
You <a href="https://vimhelp.org/vim_faq.txt.html#must" class="d">must</a> be in the right directory, otherwise Vim can't find the swap file.

<span class="h">==============================================================================</span>
<span id="11.2" class="t">11.2</span>  Where <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> the swap file?

Vim can store the swap file in several places.  Normally <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> in the same
directory <a href="https://vimhelp.org/motion.txt.html#as" class="d">as</a> the original file.  To find it, change to the directory of the
file, and use: 
<span class="e"></span>
<span class="e">        vim -r</span>
<span class="e"></span>
Vim will <a href="https://vimhelp.org/eval.txt.html#list" class="d">list</a> the swap files that <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> can find.  It will also look in other
directories where the swap file for files in the current directory may be
located.  It will not find swap files in any other directories though, <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a>
doesn't search the directory tree.
   The output could look like this:

<span class="h">        Swap files found: </span>
<span class="h">           In current directory: </span>
<span class="h">        1.    .main.c.swp </span>
<span class="h">                  owned by: mool   dated: Tue May 29 21:00:25 2001 </span>
<span class="h">                 file name: ~mool/vim/vim6/src/main.c </span>
<span class="h">                  modified: YES </span>
<span class="h">                 user name: mool   host name: masaka.moolenaar.net </span>
<span class="h">                process ID: 12525 </span>
<span class="h">           In directory ~/tmp: </span>
<span class="h">              -- none -- </span>
<span class="h">           In directory /var/tmp: </span>
<span class="h">              -- none -- </span>
<span class="h">           In directory /tmp: </span>
<span class="h">              -- none -- </span>

If there are several swap files that look like they may be the one you want to
use, <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> <a href="https://vimhelp.org/eval.txt.html#list" class="d">list</a> <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> given of these swap files and you are requested to enter the
number of the one you want to use.  Carefully look <a href="https://vimhelp.org/motion.txt.html#at" class="d">at</a> the dates to decide
which one you want to use.
   In <a href="https://vimhelp.org/change.txt.html#case" class="d">case</a> you don't know which one to use, just try them one by one and check
the resulting files if they are what you expected.


<span class="c">USING A SPECIFIC SWAP FILE</span>

If you know which swap file needs to be used, you can recover by giving the
swap file name.  Vim will then find out the name of the original file from
the swap file.

Example: 
<span class="e">        vim -r .help.txt.swo</span>
<span class="e"></span>
This <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> also handy when the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> in another directory than expected.
Vim recognizes files with the <a href="https://vimhelp.org/pattern.txt.html#pattern" class="d">pattern</a> *.s[uvw][a-z] <a href="https://vimhelp.org/motion.txt.html#as" class="d">as</a> swap files.

If this still does not work, see what file names Vim reports and rename the
files accordingly.  Check the <a href="https://vimhelp.org/options.txt.html#%27directory%27" class="o">'directory'</a> option to see where Vim may have
<a href="https://vimhelp.org/change.txt.html#put" class="d">put</a> the swap file.

        <span class="n">Note:</span>
        Vim tries to find the swap file by searching the directories in the
        <a href="https://vimhelp.org/options.txt.html#%27dir%27" class="o">'dir'</a> option, looking for files that match "filename.sw?"<a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>  If
        <a href="https://vimhelp.org/editing.txt.html#wildcard" class="d">wildcard</a> expansion doesn't work (e.g., when the <a href="https://vimhelp.org/options.txt.html#%27shell%27" class="o">'shell'</a> option <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a>
        invalid), Vim does <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> desperate try to find the file "filename.swp"<a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>
        If that fails too, you will have to give the name of the swapfile
        itself to be able to recover the file.

<span class="h">==============================================================================</span>
<span id="11.3" class="t">11.3</span>  Crashed or not?                                 <span id="ATTENTION" class="t">ATTENTION</span> <span id="E325" class="t">E325</span>

Vim tries to protect you from doing stupid things.  Suppose you innocently
start editing <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file, expecting the contents of the file to show up.  Instead,
Vim produces <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> very long message:

<span class="h">                E325: ATTENTION </span>
<span class="h">        Found a swap file by the name ".main.c.swp" </span>
<span class="h">                  owned by: mool   dated: Tue May 29 21:09:28 2001 </span>
<span class="h">                 file name: ~mool/vim/vim6/src/main.c </span>
<span class="h">                  modified: no </span>
<span class="h">                 user name: mool   host name: masaka.moolenaar.net </span>
<span class="h">                process ID: 12559 (still running) </span>
<span class="h">        While opening file "main.c" </span>
<span class="h">                     dated: Tue May 29 19:46:12 2001 </span>
<span class="h"> </span>
<span class="h">        (1) Another program may be editing the same file. </span>
<span class="h">            If this is the case, be careful not to end up with two </span>
<span class="h">            different instances of the same file when making changes. </span>
<span class="h">            Quit, or continue with caution. </span>
<span class="h"> </span>
<span class="h">        (2) An edit session for this file crashed. </span>
<span class="h">            If this is the case, use ":recover" or "vim -r main.c" </span>
<span class="h">            to recover the changes (see ":help recovery"). </span>
<span class="h">            If you did this already, delete the swap file ".main.c.swp" </span>
<span class="h">            to avoid this message. </span>

You get this message, because, when <a href="https://vimhelp.org/starting.txt.html#starting" class="d">starting</a> to edit <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file, Vim checks if <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a>
swap file already exists for that file.  If there <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> one, there <a href="https://vimhelp.org/vim_faq.txt.html#must" class="d">must</a> be
something wrong.  It may be one of these two situations.

1. Another edit session <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> active on this file.  Look in the message for the
   line with "process ID"<a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>  It might look like this:

<span class="h">                process ID: 12559 (still running) </span>

   The text "(still running)" indicates that the process editing this file
   runs on the same computer.  When working on <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> non-Unix system you will not
   get this extra hint.  When editing <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file over <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> network, you may not see
   the hint, because the process might be running on another computer.  In
   those two cases you <a href="https://vimhelp.org/vim_faq.txt.html#must" class="d">must</a> find out what the situation <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> yourself.
      If there <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> another Vim editing the same file, continuing to edit will
   result in two versions of the same file.  The one that <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> written last will
   overwrite the other one, resulting in loss of changes.  You better quit
   this Vim.

2. The swap file might be the result from <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> previous crash of Vim or the
   computer.  Check the dates mentioned in the message.  If the date of the
   swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> newer than the file you were editing, and this line appears:

<span class="h">                modified: YES </span>

   Then you very likely have <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> crashed edit session that <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> worth recovering.
      If the date of the file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> newer than the date of the swap file, then
   either <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> was changed after the crash (perhaps you recovered <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> earlier,
   but didn't delete the swap file?), or else the file was saved before the
   crash but after the last write of the swap file (then you're lucky: you
   don't even need that old swap file).  Vim will warn you for this with this
   extra line:

<span class="h">      NEWER than swap file! </span>


<span class="n">NOTE</span> that in the following situation Vim knows the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> not useful and
will automatically delete it:
<a href="https://vimhelp.org/motion.txt.html#-" class="d">-</a> The file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> valid swap file (Magic number <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> correct).
<a href="https://vimhelp.org/motion.txt.html#-" class="d">-</a> The flag that the file was modified <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> not set.
<a href="https://vimhelp.org/motion.txt.html#-" class="d">-</a> The process <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> not running.

You can programmatically deal with this situation with the <a href="https://vimhelp.org/autocmd.txt.html#FileChangedShell" class="l">FileChangedShell</a>
<a href="https://vimhelp.org/autocmd.txt.html#autocommand" class="d">autocommand</a> event.


<span class="h">UNREADABLE SWAP FILE </span>

Sometimes the line

<span class="h">        [cannot be read] </span>

will appear under the name of the swap file.  This can be good or bad,
depending on circumstances.

It <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> good if <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> previous editing session crashed without having made any
changes to the file.  Then <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> directory listing of the swap file will show
that <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> has zero bytes.  You may delete <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> and proceed.

It <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> slightly bad if you don't have read permission for the swap file.  You
may want to <a href="https://vimhelp.org/starting.txt.html#view" class="d">view</a> the file read-only, or quit.  On multi-user systems, if you
yourself did the last changes under <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> different login name, <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> logout
followed by <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> login under that other name might cure the "read error"<a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>  Or
else you might want to find out who last edited (or <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> editing) the file and
have <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> talk with them.

It <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> very bad if <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> means there <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> physical read error on the disk
containing the swap file.  Fortunately, this almost never happens.
You may want to <a href="https://vimhelp.org/starting.txt.html#view" class="d">view</a> the file read-only <a href="https://vimhelp.org/motion.txt.html#at" class="d">at</a> first (if you can), to see the
extent of the changes that were "forgotten"<a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>  If you are the one in charge of
that file, be prepared to <a href="https://vimhelp.org/undo.txt.html#redo" class="d">redo</a> your last changes.


<span class="c">WHAT TO DO?</span>                                     <span id="swap-exists-choices" class="t">swap-exists-choices</span>

If dialogs are supported you will be asked to select one of six choices:

<span class="h">  Swap file ".main.c.swp" already exists! </span>
<span class="h">  [O]pen Read-Only, (E)dit anyway, (R)ecover, (Q)uit, (A)bort, (D)elete it: </span>

<a href="https://vimhelp.org/insert.txt.html#O" class="d">O</a>  Open the file readonly.  Use this when you just want to <a href="https://vimhelp.org/starting.txt.html#view" class="d">view</a> the file and
   don't need to recover it.  You might want to use this when you know someone
   else <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> editing the file, but you just want to look in <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> and not make
   changes.

<a href="https://vimhelp.org/motion.txt.html#E" class="d">E</a>  Edit the file anyway.  Use this with caution!  If the file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> being edited
   in another Vim, you might <a href="https://vimhelp.org/intro.txt.html#end" class="d">end</a> up with two versions of the file.  Vim will
   try to warn you when this happens, but better be safe than sorry.

<a href="https://vimhelp.org/change.txt.html#R" class="d">R</a>  Recover the file from the swap file.  Use this if you know that the swap
   file contains changes that you want to recover.

<a href="https://vimhelp.org/intro.txt.html#Q" class="d">Q</a>  Quit.  This avoids <a href="https://vimhelp.org/starting.txt.html#starting" class="d">starting</a> to edit the file.  Use this if there <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> another
   Vim editing the same file.
      When you just started Vim, this will exit Vim.  When <a href="https://vimhelp.org/starting.txt.html#starting" class="d">starting</a> Vim with
   files in several windows, Vim quits only if there <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> swap file for the
   first one.  When using an edit command, the file will not be loaded and you
   are taken back to the previously edited file.

<a href="https://vimhelp.org/insert.txt.html#A" class="d">A</a>  Abort.  Like Quit, but also abort further commands.  This <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> useful when
   loading <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> <a href="https://vimhelp.org/usr_41.txt.html#script" class="d">script</a> that edits several files, such <a href="https://vimhelp.org/motion.txt.html#as" class="d">as</a> <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> session with multiple
   windows.

<a href="https://vimhelp.org/change.txt.html#D" class="d">D</a>  Delete the swap file.  Use this when you are sure you no longer need it.
   For example, when <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> doesn't contain changes, or when the file itself <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a>
   newer than the swap file.
      On <a href="https://vimhelp.org/os_unix.txt.html#Unix" class="d">Unix</a> this choice <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> only offered when the process that created the
   swap file does not appear to be running.

If you <a href="https://vimhelp.org/diff.txt.html#do" class="d">do</a> not get the <a href="https://vimhelp.org/gui_w32.txt.html#dialog" class="d">dialog</a> (you are running <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> version of Vim that does not
support it), you will have to <a href="https://vimhelp.org/diff.txt.html#do" class="d">do</a> <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> manually.  To recover the file, use this
command: 
<span class="e"></span>
<span class="e">        :recover</span>
<span class="e"></span>
<span class="e"></span>
Vim cannot always detect that <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> swap file already exists for <a href="https://vimhelp.org/insert.txt.html#a" class="d">a</a> file.  This <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a>
the <a href="https://vimhelp.org/change.txt.html#case" class="d">case</a> when the other edit session puts the swap files in another directory
or when the path name for the file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> different when editing <a href="https://vimhelp.org/motion.txt.html#it" class="d">it</a> on different
machines.  Therefore, don't rely on Vim always warning you.

If you really don't want to see this message, you can add the 'A' flag to the
<a href="https://vimhelp.org/options.txt.html#%27shortmess%27" class="o">'shortmess'</a> option.  But it's very unusual that you need this.

For remarks about <a href="https://vimhelp.org/editing.txt.html#encryption" class="d">encryption</a> and the swap file, see <a href="https://vimhelp.org/recover.txt.html#%3Arecover-crypt" class="l">:recover-crypt</a><a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>
For programmatic access to the swap file, see <a href="https://vimhelp.org/builtin.txt.html#swapinfo%28%29" class="l">swapinfo()</a><a href="https://vimhelp.org/repeat.txt.html#." class="d">.</a>

<span class="h">==============================================================================</span>
<span id="11.4" class="t">11.4</span>  Further reading

<a href="https://vimhelp.org/recover.txt.html#swap-file" class="l">swap-file</a>     An explanation about where the swap file will be created and
                what its name is.
<a href="https://vimhelp.org/recover.txt.html#%3Apreserve" class="l">:preserve</a>     Manually flushing the swap file to disk.
<a href="https://vimhelp.org/recover.txt.html#%3Aswapname" class="l">:swapname</a>     See the name of the swap file for the current file.
<a href="https://vimhelp.org/options.txt.html#%27updatecount%27" class="o">'updatecount'</a>   <a href="https://vimhelp.org/eval.txt.html#Number" class="d">Number</a> of key strokes after which the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> flushed to
                disk.
<a href="https://vimhelp.org/options.txt.html#%27updatetime%27" class="o">'updatetime'</a>    Timeout after which the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> flushed to disk.
<a href="https://vimhelp.org/options.txt.html#%27swapsync%27" class="o">'swapsync'</a>      Whether the disk <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> synced when the swap file <a href="https://vimhelp.org/motion.txt.html#is" class="d">is</a> flushed.
<a href="https://vimhelp.org/options.txt.html#%27directory%27" class="o">'directory'</a>     <a href="https://vimhelp.org/eval.txt.html#List" class="d">List</a> of directory names where to store the swap file.
<a href="https://vimhelp.org/options.txt.html#%27maxmem%27" class="o">'maxmem'</a>        Limit for memory usage before <a href="https://vimhelp.org/editing.txt.html#writing" class="d">writing</a> text to the swap file.
<a href="https://vimhelp.org/options.txt.html#%27maxmemtot%27" class="o">'maxmemtot'</a>     Same, but for all files in total.

<span class="h">==============================================================================</span>

Next chapter: <a href="https://vimhelp.org/usr_12.txt.html#usr_12.txt" class="l">usr_12.txt</a>  Clever tricks

Copyright: see <a href="https://vimhelp.org/usr_01.txt.html#manual-copyright" class="l">manual-copyright</a>  vim:tw=78:ts=8:noet:ft=help:norl:


</pre>
</div>
<div id="vh-sidebar" style="visibility: visible; position: sticky; left: 114.308px;"><ul><li><a href="#">↑Top↑</a></li><li><a href="#11.1">Basic recovery</a></li><li><a href="#11.2">Where is the swap file?</a></li><li><a href="#11.3">Crashed or not?</a></li><li><a href="#11.4">Further reading</a></li></ul></div>
</main>
<p>
Quick links:
<a href="https://vimhelp.org/">help overview</a> ·
<a href="https://vimhelp.org/quickref.txt.html">quick reference</a> ·
<a href="https://vimhelp.org/usr_toc.txt.html">user manual toc</a> ·
<a href="https://vimhelp.org/#reference_toc">reference manual toc</a>
· <a href="https://vimhelp.org/vim_faq.txt.html">faq</a></p>
<footer>This site is maintained by Carlo Teubner (<i>(my first name) at cteubner dot net</i>).</footer>


<div id="sourcegraph-app-background" data-platform="firefox-extension" data-version="22.11.24.1820" style="display: none;"></div></body></html>