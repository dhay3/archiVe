# Web常见漏洞

参考：

https://www.jianshu.com/p/4fcb4b411a66

https://www.kanxue.com

## Brute force

### 概述

$$
暴力破解 == 连续性尝试 + 字典 + 自动化
$$

一个有效的字典，可以大大的提高暴力破解的效率

- 常用的账号密码(弱口令)，比如常用用户名/密码TOP 500

- 互联网上被脱裤后账号密码(社工库)，比如CSDN当年泄漏的约600w用户信息
- 使用指定的字符使用工具按照指定的规则进行排列组合算法生成的密码

> 技巧一:
>
> 根据注册提示信息进行优化，对目标站点进行注册，搞清楚账号密码的一些限制，比如目标站点要求密码必须是6位以上，字母数字组合，则可以按照此优化字典，比如去掉不符合要求的密码。
>
> 技巧二：
>
> 如果爆破的是管理后台，往往这种系统的管理员是admin/administrator/root的几率比较高，可以使用这三个账号+随便一个密码，尝试登入，观看返回的结果，确定用户名。
>
> 比如：
>
> 输入xxx/yyyf 返回 “用户名或密码错误”
>
> 输入admin/yyy 返回 “密码错误”，则基本可以确定用户名是admin
>
> 因此可以只对密码进行爆破即可，提高效率。

### 验证码

Completely Automated Public Turing test to tell Computers and Humans Apart 简称 CAPTCHA

> 验证码用来做什么？
>
> 防止暴力破解
>
> 防止机器恶意注册

### 步骤

客户端request登入页面，后台生成验证码：

1. 后台使用算法生成图片，并将图片reponse给客户端
2. 同时将算法生成的值全局赋值存到session中

验证校验码

1. 客户端将认证信息和验证码一同提交
2. 后台对提价的验证码与session里面的进行比较

客户端重新刷新页面，再次生成新的校验码

验证算法中一般包含随机函数，所以每次刷新都会改变

### 验证码前端问题

> 不应该用前端处理验证码，需要使用图片做为验证码。将验证码的内容存入session或是redis中

```js
function validate() {
        var inputCode = document.querySelector('#bf_client .vcode').value;
        if (inputCode.length <= 0) {
            alert("请输入验证码！");
            return false;
        } else if (inputCode != code) {
            alert("验证码输入错误！");
            createCode();//刷新验证码
            return false;
        }
        else {
            return true;
        }
    }
```

这里的校验就是不安全的，请求同样会到达后端。可以通过前端路由解决，使用后端校验是最佳的。

### 验证码后端问题

> 验证码未设置过期时间，验证码设计的太过简单和有规律，如果后端验证码不设置过期时间，就可以一直尝试暴力破解

## XSS

### 概述

Cross Site Scripting 简称 XSS(跨站脚本攻击)。是一种注入攻击，当web应用对用户输入过滤不严格，攻击者写u人恶意的脚本代码(HTML, JavaScript)到网页中时，如果用户访问了含有恶意代码的页面，恶意脚本就会被浏览器解析执行导致用户被攻击。

常见的危害有：cookie窃取，sesssion劫持，钓鱼攻击，蠕虫，DDos

### 分类

- 反射型XSS

  反射型xss一般出现在URL参数种及网站搜索栏中，由于需要点击包含恶意代码的URL才可触发，并且只能触发一次，所以也被称为“==非持久型XSS==”。

- 存储型XSS

  存储型XSS一般出现在网站留言板，评论处，个人资料处，==等需要用户可以对网站写入数据的地方。==比如一个论坛评论处由于对用户输入过滤不严格，导致攻击者在写入一段窃取cookie的恶意JavaScript代码到评论处，这段恶意代码会写入数据库，当其他用户浏览这个写入代码的页面时，网站从数据库中读取恶意代码显示到网站中被浏览器执行，导致用户cookie被窃取，攻击者无需受害者密码即可登入账户。所以也被称为“==持久型==XSS”。持久型比反射型XSS危害要大的多。

- DOM型XSS

  DOM是一个与平台、编程语言无关的接口，==它允许程序或脚本动态地访问和更新文档内容、结构和样式，处理后的结果能够成为显示页面的一部分==。DOM中有很多对象，其中一些是用户可以操纵的，如uRI ，location，refelTer等。客户端的脚本程序可以通过DOM动态地检查和修改页面内容，它不依赖于提交数据到服务器端，而从客户端获得DOM中的数据在本地执行，如果DOM中的数据没有经过严格确认，就会产生DOM XSS漏洞。

### 绕过

1. 前端限制绕过，直接抓包重放，或者修改html前端代码
2. 大小写`<SCRipt>aleRT(123)</SCRIPT>`
3. 拼凑`<scri<script>pt>alert(123)</scri</script>pt>`
4. 使用注释`<scri<!--test-->pt>alter(123)</sc<!--test-->ript>`
5. 使用特殊DOM对象`<img onerror="alert(123)">`

### 防范措施

> 输入做过滤，输出做转译

过滤：根据业务进行过滤，比如输入点要求输入手机号，则只允许输入手机号码格式的数字

转译：所有输出到前端的数据都根据输出点进行转译，比如输出到html中进行html实体转译，输入到JS里面的进行JS转译

## CSRF

### 概述

Cross Site Request Forgery 简称CSRF (跨站站点请求伪造)。攻击者盗用了你的身份，以你的名义发送恶意请求，对服务器来说这个请求是完全合法的，但是却完成了攻击者所期望的一个操作，比如以你的名义发送邮件，法消息，盗取你的账号，添加系统管理员，甚至于购买商品、虚拟货币转账等。

以两个例子说明

- 案例一

  一个银行站点存在一个csrf漏洞，用户A转账B用户2000元，执行转账操作后会对银行发送一次请求`http://www.bank.com/money?user=A&num=2000&transfer=B`，然后A用户就会把自己的2000元转到B的账户下。在发送这个请求给银行服务器时，服务器首先会验证这个请求是否为一个合法的session，并且用户A确认登入才可以验证通过。

  如果此时有一个恶意用户C像把A用户的钱转到自己的账户下，那么他可以构造` http://www.bank.com/money?user=A&num=2000&transfer=C`这个请求，但是这个请求必须由A用户发出才可以生效，此时恶意用户C可以搭建一个自己的站点，在网站中写入如下代码`<img src="http://www.bank.com/money?user=A&num=2000&transfer=C">`，之后诱导A用户访问自己的站点，当A访问了这个网站时，这个网站就会把img标签里的URL发送给银行服务器，而且除了这个请求以外，还会把A用户的cookie一起发送到服务器，如果此时A用户的浏览器与银行的sessions没有过期，那么就会在A用户毫不知情的情况下执行转账给C的操作。==访问银行站点时，使用的银行域下的cookie, 也就不存在跨域==

- 案例二

  一个cms系统的管理后台，可以发送一个post请求添加一个管理员，由于没有加token或者验证码限制，恶意攻击者可以在自己的服务器evil.com上建立一个a.html的文件，a.html文件是一个添加管理员账户的表单，上面写入需要添加的账户用户名及密码，当网站管理员打开evil.com/a.html的时候，并且管理员sessions(cookie中含有sessionID)没有失效，那么此时a.html就会请求受攻击站点，在管理员毫不知情的情况下添加一个后台账户

  但是查询数据的地方却不需要保护，==因为csrf是借助受害者的cookie来进行攻击者需要的恶意操作的，攻击者并不能拿到受害者cookie，对于服务器返回的结果也无法解析查看，攻击者唯一可以做的就是让服务器执行自己的操作命令，或者说改变网站数据，而查询操作即不会改变数据也不会把结果返回给攻击者，所以并不需要保护。==

### 危害

1. 对网站管理员进行攻击
2. 修改受害者网站上的用户账户和数据
3. 账户劫持
4. 传播CSRF蠕虫进行大规模攻击
5. 利用CSRF进行拖库
6. 利用其他漏洞进行漏洞进行组合
7. 针对路由器的CSRF攻击

### 解决

1. 使用验证码

   csrf攻击一般都是在受害者不知情的情况下，使用验证码可以有效的防止攻击，但是每次请求都要输入验证码会影响用户体验，所以通常只在用户登入注册，还有一些特定业务场景下使用，比如银行转账。如何使用验证码要根据业务和场景来决定

2. 验证http Referer

   http头中的referer字段记录了请求来源地址，比如从`http://www.test.com `点击链接到 `http://m.test.com `之后，那么referer就是` http://www.test.com `这个地址。攻击者在对受害者进行攻击的时候，是在攻击者自己的服务器上构建自己的恶意脚本，诱骗受害者点击，所以此时的referer值就是攻击者自己的URL地址。

   通过以上可知，csrf攻击都是跨域发起的，所以在服务端针对referer字段验证是否属于安全可靠的域名，可在一定程度上有效防御此类攻击。

   但是此类方法并非万无一失，在低版本存在漏洞的浏览器中，黑客可以篡改referer值。另一种情况是csrf结合xss进行攻击，此时就不需要跨域发送，也可以绕过referer验证。

3. 使用token

   在说token如何防御csrf攻击之前，我们了解下token的工作原理。当用户第一次进行登陆时，客户端会通过用户名和密码去请求服务器登陆，服务端在收到请求后会验证客户端传来的用户名和密码，如果验证通过，服务端就会签发一个token发送给客户端，并且将token放到session中，客户端收到token后存储到本地，以后客户端只要每次请求服务器就要带上token，经过服务器验证通过后才会返回响应数据，否则报错。

   csrf攻击成功的前提条件是攻击者可以完全伪造处受害者的所有请求，而且请求中的验证信息都在cookie中，黑客只要使用用户的cookie通过安全验证就可以完成攻击。了解这些之后，想要防止csrf攻击，==就要在http请求中放置黑客不可以伪造的信息，而且该信息不可以存在于cookie中，否则就无效。==而token令牌最大的特点就是随机性，不可预测，并且不存在于cookie中。

   对于GET请求，请求参数直接在URL当中，这样token的形式就为`http://xxx.com?csrftoken=tokenvalue`，但是这种方式把请求参数都放在URL中，会导致在referer中泄漏，不仅如此，设想另一种场景，一个在内网系统的员工，从内部敏感系统在点击对外部提供服务的网站连接，此时就会把内网敏感信息通过referer泄漏出去。而对于POST请求，token是隐藏表单存在，`<input type=”hidden” name=”csrftoken” value=”tokenvalue”/>`

   最后一点，==如果在同域下存在xss漏洞，那么这种tokoen的防御将形同虚设==

## SSRF

Server-Side Request Forgery 简称SSRF(服务端请求伪造)，是一种由攻击者构造形成由服务端发起请求的一个安全漏洞。在一般情况下，SSRF攻击目标是从外网无法访问的内部系统。正是因为它是由服务端发起的，==所以它能够请求到与它相连而与外网隔离的内部系统==

正常情况下，我们无法从外网去访问一个公司的内部系统，但是如果服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。攻击者就可以利用该漏洞绕过防火墙等访问限制，进而将受感染或存在漏洞的服务器作为代理进行端口扫描，甚至是访问内部系统数据。

### ssrf的攻击利用主要有以下几种：

1. 内网、本地端口扫描，获取开放端口信息
2. 主机信息收集，web应用指纹识别，获取服务banner信息
3. 根据识别出的应用针对性的发送payload攻击，例如struts2
4. 攻击内网和本地的应用程序及服务。

5. 穿越防火墙
6. 利用file协议读取本地文件，比如file:///etc/passwd

### 一般存在于

1. 在线分享：通过URL地址分享网页内容
2. 在线识图
3. 在线翻译：百度翻译，有道翻译
4. 各大网站订阅
5. 图片加载于下载：通过URL地址加载或下载图片
6. 图片，文章收藏功能
7. 接收邮件服务地址的邮件系统
8. 调用URL的功能
9. 文件处理，如ImageMagick， xml
10. 请求远程服务器资源，远程URL上传，静态资源图片文件等
11. 数据库内置功能，比如mongodb和copyDatabase函数
12. 从URL关键字中寻找：share，url，link，src，source，sourceURL，imageURL，domain

<img src="..\..\imgs\_Net\Snipaste_2020-09-12_13-13-13.png"/>

### 漏洞验证方式

1、右键图片在新窗口打开，如果浏览器地址显示为 `www.xxx.com/xx.jpg `类似格式的，说明不存在ssrf漏洞，但是如果资源地址类似 `http://www.xxx.com/1.jsp?image= `的格式就有可能存在漏洞。

 

2、另一种方式是使用抓包工具burp fiddler来判断，SSRF漏洞是构造服务器发送请求的安全漏洞，所以就可以通过抓包分析请求是否有服务端发起的来判断是否存在漏洞。



















